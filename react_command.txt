yarn create react-app <project-name> :
    리액트 프로젝트 생성

Reactjs code Snippet:
    rsc : 함수형 컴포넌트 생성
    rcc : 클래스형 컴포넌트 생성

JSX 문법 :
    1.감싸인 요소
        -컴포넌트에 여러 요소가 있다면, 부모 요소 하나로 감싸야한다.
        이 떄 <div>와 <Fragment>, <> (Fragment의 다른 형태)를 쓸 수 있다.

    2.자바스크립트 표현
        -자바스크립트 표현을 쓰고 싶다면 JSX내부에서 코드를 {}로 감싸면 된다.
        -ES6의 const와 let
            const는 변경이 불가능한 상수
            let은 동적인 값을 담을 수 있는 변수
            var는 scope(해당 값을 사용할 수 있는 코드 영역)가 함수 단위
            let과 const는 scope가 블록 단위

    3.if문 대신 조건부 연산자 (삼항연산자)
        -jsx에서는 if문 사용 불가
        -{} 안에 조건부 연산자를 사용
        -&&를 이용한 조건부 연산이 가능한 이유는 리액트는 false와 null를 렌더링할 때
        아무것도 나타나지 않음

    note:
        jsx는 괄호로 감싸는 것이 필수사항이 아님 감싸도 되고 안 감싸도 된다

    4.undefined를 렌더링하지 않기
        -리액트 컴포넌트에서는 undefined만 반환하여 렌더링하는 상황을 만들면 안된다
        -어떤 값이 undefined일 수도 있다면 or 연산자를 사용한다
        -jsx내부에서 undefined를 렌더링하는 것은 괜찮다
    
    5.인라인 스타일링
        - 스타일 이름 중에 -가 포함되어있다면 (background-color) -> backgroundColor
        로 카멜표기법을 이용해 바꾸어 준다.
        -style 객체를 미리 선언하고 div의 style={스타일 객체}를 넣어주는 방법과
        바로 객체로 넣어주는 방법이 있다
    
    6.class대신 className
        -html에서 css클래스를 사용할 때는 <div class="name"></div>와 같이 
        사용했다면, jsx에서는 class가 아닌 className을 써줘야 한다.
    
    7.꼭 닫아야 하는 태그
        -html에서는 태그를 닫지 않아도 오류를 출력하지 않고 자동으로 처리해주지만,
        리액트에서는 태그를 꼭 닫아줘야 한다.

    8.주석
        -JSX는 javascript와 달리 주석을 작성할 때는 {/*...*/}와 같은 형식으로 작성
        합니다. 시작태그를 여러 줄로 작성하게 되면 //으로 작성할 수도 있습니다.

ES6 문법:
    1.화살표 함수
        -이 문법은 주로 함수를 파라미터로 전달할 때 유용합니다.
        -이 문법은 기존 function을 대체 불가능합니다. 서로 가르키고 있는 this값이
        다르기 때문입니다.
        - () => { 함수 내 선언문; } 형식으로 사용하며 {}를 열어주지 않을시 연산값을
        그대로 반환합니다.
        - 함수형 컴포넌트를 사용할 때는 function과 화살표을 쓰는 것에 큰 차이가 없습니다
    
    2.비구조화 할당 문법
        -객체에서 값을 추출하는 문법을 비구조화 할당이라고 부릅니다.
        -const {name, children} = props 이런 식으로 할당할 수 있습니다.
        -함수의 파라미터에서도 사용 가능합니다.
        -배열은 const [one, two] = array 이런 식으로 사용합니다


컴포넌트 :
    1.선언
        -컴포넌트를 선언하는 방식은 두 가지로 하나는 함수형 컴포넌트, 또 다른 하나는 
        클래스형 컴포넌트입니다.
        -둘의 차이는 클래스형 컴포넌트의 경우 state 기능과 라이프사이클 기능을 사용할 수
        있다는 것과 임의 메서드를 정의할 수 있다는 것입니다.
        -클래스형 컴포넌트는 render함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할
        JSX를 반환해야 합니다.
        -함수형 컴포넌트의 장점은 선언하기 편하고, 메모리 자원도 덜 사용합니다.
        -함수형 컴포넌트는 Hooks를 사용해 클래스형과 비슷하게 사용 가능합니다.
    
    2.모듈 내보내기 및 불러오기
        -export는 다른 파일에서 이 파일을 임포트할 때 줄 클래스를 선언합니다.
        -import는 다른 파일에서 파일을 불러올 때 쓸 클래스를 선언합니다.
    
    3.props
        -props는 properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는
        요소입니다.
        -props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정할 수 있습니다
        -props 기본값 설정은 defaultProps로 합니다
        -부모 컴포넌트의 태그 사이의 내용은 children으로 들어갑니다
    
    4.propTypes를 통한 검증
        -propTypes를 통해 prop의 타입을 강제하거나 필수 prop을 정할 수 있습니다.
        -isRequired를 통해 필수 prop을 설정합니다
        -PropTypes 종류:
            array, arrayOf(다른 PropType) : 특정 PropType으로 이루어진 배열,
            bool, func, number, object, string, symbol, node,
            instanceOf(클래스), oneOf([]): 배열 요소 중 값 하나,
            oneOfType([]): 주어진 배열 안의 종류 중 하나, any
    
    5.클래스형 컴포넌트에서 props 사용
        -클래스형 컴포넌트에서는 render 함수에서 this.props를 조회하면 됩니다.
        -defaultProps와 propTypes를 클래스 내부에서 저장하는 방법도 있습니다
        -defaultProps와 propTypes는 다른 개발자들과 협업할 때, 컴포넌트에 어떤 
        prop이 필요한지 쉽게 알려줍니다.

    6.state
        -두 가지 종류의 state가 있습니다. 하나는 클래스형 컴포넌트가 가지고 있는
        state이고, 다른 하나는 함수형 컴포넌트에서 useState()라는 함수를 통해 사용하는
        state입니다.
        -클래스형 컴포넌트의 state:
            *컴포넌트의 생성자 메소드를 작성하고 반드시 super(props)를 호출해주세요
            *컴포넌트의 state는 객체 형식이어야 합니다
            *render 함수에서 현재 state를 조회할 때는 this.state를 조회하면 됩니다
            *생성자 메소드 없이 state = {값}으로 초기값을 지정할 수 있습니다
        -this.setState()로 state를 바꿀 수 있습니다 이 때 인자로 객체와 함수를 줄
        수 있습니다 함수를 줄 때는 (prevState, props)를 줄 수 있습니다 prevState는
        기존 상태이고 props는 현재 지니고 있는 props를 가르킵니다
        -this.setState가 끝난 후 특정 작업 실행하려면 두번째 인자로 특정 작업을 실행하는
        콜백함수를 등록합니다
        -useState 함수의 인자에는 상태의 초기값을 넣어줍니다. 값의 형태는 자유입니다.
        함수를 호출하면 배열이 반환되는데, 첫번째 원소는 현재 상태이고, 두 번째 원소는
        상태를 바꾸어주는 함수입니다. 이 함수를 setter라고 부릅니다. 원소를 받을 때
        비구조화 할당을 쓸 수 있습니다.
        -useState는 한 컴포넌트에서 여러번 사용해도 상관없습니다.
        -state를 사용할 때 주의 사항:
            state 값을 바꿔야 할 때는 setState 혹은 useState를 통해 전달받은
            세터 함수를 사용해야 합니다
            배열이나 객체를 업데이트 해야할 때는 사본을 만들고 그 사본의 상태를
            세터함수를 통해 업데이트합니다
        -앞으로 새로운 컴포넌트를 만들 때는 useState를 사용할 것을 권장합니다
        코드가 간결해지고 개발 팀에서 Hooks를 사용하는 것이 주가 될 것이라고 발표했기
        때문입니다