yarn create react-app <project-name> :
    리액트 프로젝트 생성

프로덕션 모드로 구동한다면:
    yarn build
    yarn global add serve
    serve -s build

Reactjs code Snippet:
    rsc : 함수형 컴포넌트 생성
    rcc : 클래스형 컴포넌트 생성

JSX 문법 :
    1.감싸인 요소
        -컴포넌트에 여러 요소가 있다면, 부모 요소 하나로 감싸야한다.
        이 떄 <div>와 <Fragment>, <> (Fragment의 다른 형태)를 쓸 수 있다.

    2.자바스크립트 표현
        -자바스크립트 표현을 쓰고 싶다면 JSX내부에서 코드를 {}로 감싸면 된다.
        -ES6의 const와 let
            const는 변경이 불가능한 상수
            let은 동적인 값을 담을 수 있는 변수
            var는 scope(해당 값을 사용할 수 있는 코드 영역)가 함수 단위
            let과 const는 scope가 블록 단위

    3.if문 대신 조건부 연산자 (삼항연산자)
        -jsx에서는 if문 사용 불가
        -{} 안에 조건부 연산자를 사용
        -&&를 이용한 조건부 연산이 가능한 이유는 리액트는 false와 null를 렌더링할 때
        아무것도 나타나지 않음

    note:
        jsx는 괄호로 감싸는 것이 필수사항이 아님 감싸도 되고 안 감싸도 된다

    4.undefined를 렌더링하지 않기
        -리액트 컴포넌트에서는 undefined만 반환하여 렌더링하는 상황을 만들면 안된다
        -어떤 값이 undefined일 수도 있다면 or 연산자를 사용한다
        -jsx내부에서 undefined를 렌더링하는 것은 괜찮다
    
    5.인라인 스타일링
        - 스타일 이름 중에 -가 포함되어있다면 (background-color) -> backgroundColor
        로 카멜표기법을 이용해 바꾸어 준다.
        -style 객체를 미리 선언하고 div의 style={스타일 객체}를 넣어주는 방법과
        바로 객체로 넣어주는 방법이 있다
    
    6.class대신 className
        -html에서 css클래스를 사용할 때는 <div class="name"></div>와 같이 
        사용했다면, jsx에서는 class가 아닌 className을 써줘야 한다.
    
    7.꼭 닫아야 하는 태그
        -html에서는 태그를 닫지 않아도 오류를 출력하지 않고 자동으로 처리해주지만,
        리액트에서는 태그를 꼭 닫아줘야 한다.

    8.주석
        -JSX는 javascript와 달리 주석을 작성할 때는 {/*...*/}와 같은 형식으로 작성
        합니다. 시작태그를 여러 줄로 작성하게 되면 //으로 작성할 수도 있습니다.

ES6 문법:
    1.화살표 함수
        -이 문법은 주로 함수를 파라미터로 전달할 때 유용합니다.
        -이 문법은 기존 function을 대체 불가능합니다. 서로 가르키고 있는 this값이
        다르기 때문입니다.
        - () => { 함수 내 선언문; } 형식으로 사용하며 {}를 열어주지 않을시 연산값을
        그대로 반환합니다.
        - 함수형 컴포넌트를 사용할 때는 function과 화살표을 쓰는 것에 큰 차이가 없습니다
    
    2.비구조화 할당 문법
        -객체에서 값을 추출하는 문법을 비구조화 할당이라고 부릅니다.
        -const {name, children} = props 이런 식으로 할당할 수 있습니다.
        -함수의 파라미터에서도 사용 가능합니다.
        -배열은 const [one, two] = array 이런 식으로 사용합니다


컴포넌트 :
    1.선언
        -컴포넌트를 선언하는 방식은 두 가지로 하나는 함수형 컴포넌트, 또 다른 하나는 
        클래스형 컴포넌트입니다.
        -둘의 차이는 클래스형 컴포넌트의 경우 state 기능과 라이프사이클 기능을 사용할 수
        있다는 것과 임의 메서드를 정의할 수 있다는 것입니다.
        -클래스형 컴포넌트는 render함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할
        JSX를 반환해야 합니다.
        -함수형 컴포넌트의 장점은 선언하기 편하고, 메모리 자원도 덜 사용합니다.
        -함수형 컴포넌트는 Hooks를 사용해 클래스형과 비슷하게 사용 가능합니다.
    
    2.모듈 내보내기 및 불러오기
        -export는 다른 파일에서 이 파일을 임포트할 때 줄 클래스를 선언합니다.
        -import는 다른 파일에서 파일을 불러올 때 쓸 클래스를 선언합니다.
    
    3.props
        -props는 properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는
        요소입니다.
        -props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정할 수 있습니다
        -props 기본값 설정은 defaultProps로 합니다
        -부모 컴포넌트의 태그 사이의 내용은 children으로 들어갑니다
    
    4.propTypes를 통한 검증
        -propTypes를 통해 prop의 타입을 강제하거나 필수 prop을 정할 수 있습니다.
        -isRequired를 통해 필수 prop을 설정합니다
        -PropTypes 종류:
            array, arrayOf(다른 PropType) : 특정 PropType으로 이루어진 배열,
            bool, func, number, object, string, symbol, node,
            instanceOf(클래스), oneOf([]): 배열 요소 중 값 하나,
            oneOfType([]): 주어진 배열 안의 종류 중 하나, any
    
    5.클래스형 컴포넌트에서 props 사용
        -클래스형 컴포넌트에서는 render 함수에서 this.props를 조회하면 됩니다.
        -defaultProps와 propTypes를 클래스 내부에서 저장하는 방법도 있습니다
        -defaultProps와 propTypes는 다른 개발자들과 협업할 때, 컴포넌트에 어떤 
        prop이 필요한지 쉽게 알려줍니다.

    6.state
        -두 가지 종류의 state가 있습니다. 하나는 클래스형 컴포넌트가 가지고 있는
        state이고, 다른 하나는 함수형 컴포넌트에서 useState()라는 함수를 통해 사용하는
        state입니다.
        -클래스형 컴포넌트의 state:
            *컴포넌트의 생성자 메소드를 작성하고 반드시 super(props)를 호출해주세요
            *컴포넌트의 state는 객체 형식이어야 합니다
            *render 함수에서 현재 state를 조회할 때는 this.state를 조회하면 됩니다
            *생성자 메소드 없이 state = {값}으로 초기값을 지정할 수 있습니다
        -this.setState()로 state를 바꿀 수 있습니다 이 때 인자로 객체와 함수를 줄
        수 있습니다 함수를 줄 때는 (prevState, props)를 줄 수 있습니다 prevState는
        기존 상태이고 props는 현재 지니고 있는 props를 가르킵니다
        -this.setState가 끝난 후 특정 작업 실행하려면 두번째 인자로 특정 작업을 실행하는
        콜백함수를 등록합니다
        -useState 함수의 인자에는 상태의 초기값을 넣어줍니다. 값의 형태는 자유입니다.
        함수를 호출하면 배열이 반환되는데, 첫번째 원소는 현재 상태이고, 두 번째 원소는
        상태를 바꾸어주는 함수입니다. 이 함수를 setter라고 부릅니다. 원소를 받을 때
        비구조화 할당을 쓸 수 있습니다.
        -useState는 한 컴포넌트에서 여러번 사용해도 상관없습니다.
        -state를 사용할 때 주의 사항:
            state 값을 바꿔야 할 때는 setState 혹은 useState를 통해 전달받은
            세터 함수를 사용해야 합니다
            배열이나 객체를 업데이트 해야할 때는 사본을 만들고 그 사본의 상태를
            세터함수를 통해 업데이트합니다
        -앞으로 새로운 컴포넌트를 만들 때는 useState를 사용할 것을 권장합니다
        코드가 간결해지고 개발 팀에서 Hooks를 사용하는 것이 주가 될 것이라고 발표했기
        때문입니다

이벤트 핸들링:
    1.이벤트를 사용할 때 주의사항
        -이벤트 이름은 카멜 표기법으로 작성합니다
        -이벤트에 실행할 자바스크립트를 전달하는 것이 아니라, 함수 형태의 값을 전달합니다
        -DOM 요소에만 이벤트를 설정할 수 있습니다 컴포넌트에 자체적으로 이벤트를 설정할 수
        는 없습니다 하지만 전달받은 props를 컴포넌트 내부의 DOM 이벤트로 설정할 수는 있죠
    2.임의 메서드 만들기
        -임의 메소드가 이벤트로 등록되어도 this를 컴포넌트 자신으로 제대로 가르키기 위해서
        는 메소드를 this와 바인딩하는 작업이 필요합니다 이를 위해 constructor 함수에서
        함수를 바인딩합니다
        -메소드 바인딩은 생성자 메소드에서 하는 것이 정석입니다만, 이 작업이 불편합니다
        이를 대체해 바벨의 transform-class-properties 문법을 사용하여 
        화살표 함수 형태로 메소드를 정의합니다
    3.input 여러개 다루기
        -input이 여러 개일 때는 메소드도 여러 개 만들어 작업할 수도 있지만, 더 쉽게
        처리하는 방법이 있습니다 event 객체를 활용하는 것 입니다
        -e.target.name은 input의 name을 가르킵니다
        -객체 안에 key를 [ ]로 감싸면 그 안에 넣은 레퍼런스가 가르키는 실제 값이
        key 값으로 사용됩니다
    4.함수형 컴포넌트
        -useState를 통해 클래스형과 똑같이 다룰 수 있습니다

ref:
    1.ref란?
        -ref는 리액트 프로젝트 내부에서 DOM에 이름을 다는 방법입니다 DOM의 id와 비슷합니다
        -id를 사용할 수도 있습니다만, 권장하지는 않습니다 같은 컴포넌트를 여러번 사용하다보면
        id가 유일해지지 않기 때문입니다 ref는 전역적으로 작동하지 않기 때문에 이런 문제가
        생기지 않습니다
    2.어떤 상황에서 ref를 사용하는가
        -DOM을 꼭 직접적으로 건드려야 할 때 사용합니다
        -DOM을 꼭 사용해야 하는 상황
            특정 input에 포커스 주기
            스크롤 박스 조작하기
            Canvas 요소에 그림 그리기 등
    3.ref 사용
        -콜백 함수를 통한 ref 설정: ref를 달고자 하는 요소에 ref라는 콜백 함수를 
        props로 전달해 줍니다 그리고 함수 내부에서 파라미터로 받은 ref를 컴포넌트의
        멤버 변수로 설정해 줍니다
        -createRef를 통한 ref 설정: 리액트에 내장되어 있는 createRef라는 함수를
        사용합니다 설정한 뒤 나중에 ref를 설정해 준 DOM에 접근하려면 this.input.
        current를 조회합니다
    4.컴포넌트에 ref 달기
        -이 방법은 주로 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 씁니다
        컴포넌트에 ref를 다는 방법은 DOM에 ref를 다는 방법과 같습니다
        -사용법 <MyComponent ref={(ref)=>{this.myComponent = ref}}/>
        -이렇게 하면 MyComponent 내부의 메소드 및 멤버 변수에도 접근 가능합니다
    5.ref를 사용할 때 주의할 점
        -서로 다른 컴포넌트끼리 데이터를 교류할 때 ref를 사용하지 않습니다
        사용할 수는 있지만, 유지보수 문제 때문에 사용하지 않습니다

컴포넌트 반복:
    1.배열의 map() 함수: arr.map(callback, [thisArg])
        callback: 새로운 배열의 요소를 생성하는 함수로 파라미터는 다음 세 가지입니다
            -currentValue: 현재 처리하고 있는 요소
            -index: 현재 처리하고 있는 요소의 index 값
            -array: 현재 처리하고 있는 원본 배열
        thisArg(선택항목) : callback 함수 내부에서 사용할 this 레퍼런스
    2.key
        -리액트에서 key는 컴포넌트 배열을 렌더링했을 때 어떤 원소에 변동이 있었는지
        알아내려고 사용합니다 key가 없을 때는 Virtual DOM을 비교할 때 순차적으로
        비교합니다 key가 있을때는 어떤 변화가 일어났는지 더욱 빠르게 알아낼 수
        있습니다
        -key 값을 설정할 때는 map 함수의 인자로 전달되는 함수 내부에서 
        컴포넌트 props를 설정하듯이 설정하면 됩니다 key 값은 유일해야 합니다
        -고유한 값이 없을 때는 index 값을 key로 사용해야 합니다 
        index를 key로 사용하면 배열이 변경될 때 효율적으로 리렌더링하지 
        못합니다
    3.리액트 상태 업데이트
        -리액트에서 상태를 업데이트할 때는 기존 상태를 그대로 두면서 새로운 값을
        상태로 설정해야 합니다 이를 불변성 유지라고 합니다 불변성 유지를 해주어야
        리액트 컴포넌트의 성능을 최적화할 수 있습니다
        -이를 위해 배열에 추가할 때는 concat을 사용하고 삭제할 때는 filter를
        써줍니다

컴포넌트의 라이프사이클 메소드:
    1.라이프사이클 메소드의 이해
        -모든 리액트 컴포넌트에는 라이프사이클이 존재합니다
        컴포넌트의 수명은 페이지에 렌더링되기 전인 준비 과정에서 시작하여 페이지
        에서 사라질 때 끝납니다
        -라이프사이클 메소드는 클래스형 컴포넌트에서만 사용할 수 있습니다 
        함수형 컴포넌트에서는 Hooks 기능을 사용하여 비슷하게 처리합니다
        -라이프사이클 메소드의 종류는 총 아홉 가지입니다
        -Will 접두사가 붙은 메소드는 어떤 작업을 작동하기 전에 실행되는 메소드
        이고 Did 접두사가 붙은 메소드는 어떤 작업을 작동한 후에 실행됩니다
        -라이프사이클은 총 세가지, 마운트, 업데이트, 언마운트로 나눕니다
    2.마운트
        -DOM이 생성되고 웹 브라우저 상에 나타나는 것을 mount라고 합니다
        이 떄 호출하는 메소드는 다음과 같습니다
            컴포넌트 만들기 -> constructor -> getDerivedStateFromProps
            -> render -> componentDidMount
        constructor: 컴포넌트를 새로 만들 때마다 호출되는 클래스 생성자 메소드
        getDerivedStateFromProps: props에 있는 값을 state에 넣을 때
                                사용하는 메소드
        render: 우리가 준비한 UI를 렌더링하는 메소드
        componentDidMount: 컴포넌트가 웹 브라우저에 나타난 후 호출하는 메소드
    3.업데이트
        -컴포넌트는 다음과 같은 총 네가지 경우에 업데이트합니다
            1.props가 바뀔 때
            2.state가 바뀔 때
            3.부모 컴포넌트가 리렌더링될 때
            4.this.forceUpdate로 강제로 렌더링을 트리거할 때
        업데이트할 때 호출되는 메소드는 다음과 같습니다
            업데이트 발생 -> getDerivedStateFromProps ->
            shouldComponentUpdate(false반환 시 여기서 작업 취소)
             -> render (true반환시) -> getSnapshotBeforeUpdate
             -> 웹 브라우저상의 실제 DOM 변화 -> componentDidUpdate
        shouldComponentUpdate : 컴포넌트가 리렌더링을 해야 할지
        말아야 할지를 결정하는 메소드입니다 만약, 특정 함수에서 
        this.forceUpdate() 함수를 호출하면 이 과정을 생략합니다
        getSnapshotBeforeUpdate : 컴포넌트 변화를 DOM에 반영하기 바로 전에
                                호출하는 메소드
        componentDidUpdate : 컴포넌트의 업데이트가 끝나고 호출하는 메소드
    4.언마운트
        -마운트의 반대 과정, 즉 컴포넌트를 DOM에서 제거하는 것을 가르킵니다
            언마운트하기 -> componentWillUnmount
        componentWillUnmount : 컴포넌트가 웹 브라우저상에서 사라지기 전에
                            호출하는 메소드입니다
    5.render() 함수
        -이 메소드는 컴포넌트의 모양새를 정의합니다 라이프사이클 메소드 중
        유일한 필수 메소드입니다
        -이 메소드 안에서 this.props와 this.state에 접근할 수 있으며,
        리액트 요소를 반환합니다
        -이 메소드 안에서는 이벤트 설정이 아닌 곳에서 setState를 사용해서는
        안되며, 브라우저 DOM에 접근해서도 안됩니다
        -DOM 정보를 가져오거나 state에 변화를 줄 떄는 componentDidMount에서
        처리해야 합니다

    6. constructor 메소드
        -컴포넌트의 생성자 메소드로 컴포넌트를 만들 때 처음으로 실행됩니다
        이 메소드에서는 초기 state를 정할 수 있습니다

    7.getDerivedStateFromProps 메소드
        -props로 받아 온 값을 state에 동기화시키는 용도로 사용하며, 
        컴포넌트가 마운트될 떄와 업데이트될 때 호출됩니다

    8.componentDidMount 메소드
        -컴포넌트를 만들고, 첫 렌더링을 마친 후 실행합니다
        -이 안에서 다른 자바스크립트 라이브러리 또는 프레임워크의 함수를
        호출하거나 이벤트 등록, setTimeout, setInterval, 네트워크
        요청 같은 비동기 작업을 처리하면 됩니다

    9.shouldComponentUpdate 메소드
        -props 또는 state를 변경했을 때, 리렌더링을 시작할지 여부를 정하는 메소드
        -이 메소드에서는 반드시 true 값 또는 false 값을 반환해야 합니다
        -컴포넌트를 만들 때 이 메소드를 따로 생성하지 않으면 기본적으로 true를 
        반환합니다 false를 반환할 시 업데이트 과정을 여기서 중지됩니다
        -이 메소드 안에서 현재 props와 state는 this.props와 this.state로 
        접근하고, 새로 생성될 것은 nextProps와 nextState로 접근합니다

    10.getSnapshotBeforeUpdate 메소드
        -이 메소드는 render에서 만들어진 결과물이 브라우저에 반영되기 직전에 
        호출됩니다
        -이 메소드의 반환 값은 componentDidUpdate에 세 번째 파라미터인
        snapshot 값으로 전달받을 수 있는데, 주로 업데이트하기 직전의 값을
        참고할 일이 있을 때 활용됩니다 (예: 스크롤바 위치 유지)

    11. componentDidUpdate 메소드
        -리렌더링을 완료한 후 실행됩니다 업데이트가 끝난 직후이므로,
        DOM 관련 처리를 해도 무방합니다
        -여기서 prevProps 또는 prevState를 사용하여 컴포넌트가
        이전에 가졌던 데이터에 접근할 수 있습니다

    12. componentWillUnmount 메소드
        -컴포넌트를 DOM에서 제거할 때 실행합니다 componentDidMount에서 
        등록한 이벤트, 타이머, 직접 생성한 DOM이 있다면 여기서 제거해야 합니다

    13. componentDidCatch 메소드
        -컴포넌트 렌더링 도중에 에러가 발생했을 때 에플리케이션이 먹통이
        되지 않고 오류 UI를 보여줄 수 있게 합니다 
        -컴포넌트 자신에게 발생하는 에러를 잡아낼 수 없고 자신의 
        this.props.children으로 전달되는 컴포넌트에서 발생하는 에러만
        잡아낼 수 있다는 점을 알아두어야 합니다

Hooks : 
    1.Hooks란?
        -함수형 컴포넌트에서도 상태 관리를 할 수 있는 useState, 렌더링 
        직후 작업을 설정하는 useEffect 등의 기능을 제공하여 기존의 함수형
        컴포넌트에서 할 수 없었던 다양한 작업을 할 수 있게 해 줍니다.  

    2.useState
        -가장 기본적인 Hook이며, 함수형 컴포넌트에서도 가변적인 상태를
        지닐 수 있게 해줍니다.
        -파라미터에는 상태의 기본값을 넣어줍니다
        -배열을 반환합니다 그 배열의 첫 번째 원소는 상태 값, 두 번째 원소는
        상태를 설정하는 함수입니다
        -하나의 useState 함수는 하나의 상태 값만 관리할 수 있습니다 
        컴포넌트에서 관리해야 할 상태가 여러개라면 useState를 여러 번 사용합니다

    3.useEffect
        -리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수
        있는 Hook입니다 
        -클래스형 컴포넌트의 componentDidMount와 componentDidUpdate를
        합친 형태로 보아도 무방합니다
        -마운트될 때만 실행하고 싶다면 두 번째 파라미터로 [] 빈 배열을
        넣어주면 됩니다
        -특정 값이 업데이트될 때만 실행하고 싶다면 두 번째 파라미터로 전달되는
        배열 안에 검사하고 싶은 값을 넣어주면 됩니다
        -언마운트 되기 전이나 업데이트 되기 직전에 어떠한 작업을 수행하고
        싶다면 뒷정리 함수를 반환해 주어야 합니다
        -언마운트될 때만 뒷정리 함수를 호출하고 싶다면 두번째 파라미터에
        비어 있는 배열을 넣으면 됩니다

    4.useReducer
        -useState보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른
        값으로 업데이트할 때 쓰는 Hook입니다
        -리듀서는 현재 상태, 그리고 업데이트를 위해 필요한 정보를 담은
        액션 값을 전달받아 새로운 상태를 반환하는 함수입니다 리듀서 함수
        에서 새로운 상태를 만들 때는 반드시 불변성을 지켜 주어야 합니다
        -액션 값은 다음과 같은 형태입니다
            {
                type: 'INCREMENT',
                //다른 값들이 필요하다면 추가로 들어감
            }
        -액션 객체는 반드시 type을 지니고 있을 필요가 없습니다 심지어,
        객체가 아니라 문자열이나 숫자여도 상관없습니다
        -useReducer의 첫번째 파라미터에는 리듀서 함수를 넣고,
        두 번째 파라미터에는 해당 리듀서의 기본값을 넣어줍니다
        -이 Hook을 사용하면 state값과 dispatch함수를 받아옵니다
        -state는 현재 가르키고 있는 상태이고, dispatch는 액션을
        발생시키는 함수입니다
        -dispatch(action)과 같은 형태로, 함수 안에 파라미터로 액션
        값을 넣어주면 리듀서 함수가 호출되는 구조입니다
        -useReducer의 가장 큰 장점은 컴포넌트 업데이트 로직을 
        컴포넌트 바깥으로 빼낼 수 있다는 것입니다
    
    5.useMemo
        -함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있습니다
        -중복 생성되는 연산을 한번으로 줄일 수 있습니다

    6.useCallback
        -useMemo와 비슷한 함수로 주로 렌더링 성능을 최적화해야 하는
        상황에서 사용합니다 이 Hook을 사용하면 이벤트 핸들러 함수를
        필요할 때만 생성할 수 있습니다
        -컴포넌트의 렌더링이 자주 발생하거나 렌더링해야 할 컴포넌트의
        개수가 많아지면 이 부분을 최적화해 주는 것이 좋습니다
        -useCallback의 첫 번째 파라미터에는 생성하고 싶은 함수를
        넣고, 두 번째 파라미터에는 배열을 넣으면 됩니다 이 배열에는
        어떤 값이 바뀌었을 때 함수를 새로 생성해야 하는지 명시해야
        합니다
        -비어있는 배열을 넣게 되면 컴포넌트가 렌더링될 떄 단 한번만
        함수가 생성되며, 값을 넣으면 그 값이 변경될 때마다 함수가
        생성됩니다
        -함수 내부에서 상태 값에 의존해야 할 때는 그 값을 반드시
        두 번째 파라미터 안에 포함시켜 주어야 합니다
        -숫자,문자열,객체처럼 일반 값을 재사용하려면 useMemo를,
        함수를 재사용하려면 useCallback을 사용합니다

    7.useRef
        -함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해줍니다
        -로컬 변수를 사용해야 할 때도 useRef를 활용할 수 있습니다
        로컬 변수란 렌더링과 상관없이 바뀔 수 있는 값을 의미합니다

    8.커스텀 Hooks
        -새로운 파일을 만들어 새로운 Hook을 만들 수 있습니다
    
    9.정리
        -메뉴얼에서는 새로 작성하는 컴포넌트의 경우 함수형 컴포넌트와
        Hooks를 사용하길 권장합니다

컴포넌트 스타일링:
    리액트에서 컴포넌트를 스타일링할 때는 다양한 방식을 사용할 수 있습니다
    여러 방식 중에서 딱히 정해진 방식은 없습니다
    스타일링 방식은 다음과 같습니다
    -일반 CSS : 컴포넌트를 스타일링하는 가장 기본적인 방식입니다
    -Sass: 자주 사용되는 CSS 전처리기 중 하나로 확정된 CSS 문법을
            사용하여 CSS 코드를 더욱 쉽게 작성할 수 있도록 해줍니다
    -CSS Module : 스타일을 작성할 때 CSS 클래스가 다른 CSS 클래스의
                이름과 절대 충돌하지 않도록 파일마다 고유한 이름을 
                자동으로 생성해 주는 옵션입니다
    -styled-components: 스타일을 자바스크립트 파일에 내장시키는
                    방식으로 스타일을 적용함과 동시에 해당 스타일이
                    적용된 컴포넌트를 만들 수 있게 해 줍니다
    
    1.가장 흔한 방식, 일반 CSS:
        -새로운 기술을 배울 필요가 없다고 생각되면, 일반 CSS를 
        사용해도 상관없습니다
        -CSS를 작성할 때 가장 중요한 점은 CSS 클래스를 중복되지
        않게 만드는 것입니다
        -중복되는 것을 방지하는 여러 가지 방식이 있는데, 그 중
        하나는 이름을 지을 때 특별한 규칙을 사용하여 짓는 것이고,
        다른 하나는 CSS Selector를 활용하는 것입니다
        -이름 짓는 규칙:
            클래스 이름에 컴포넌트 이름을 포함시킴으로써 다른
            컴포넌트에서 실수를 줄일 수 있습니다
            비슷한 방식으로 BEM 네이밍이라는 방식이 있습니다
            BEM 네이밍은 CSS 방법론 중 하나로, 이름을 
            지을 때 일종의 규칙을 준수하여 해당 클래스가
            어디에서 어떤 용도로 사용되는지 명확하게
            작성하는 방식입니다
        -CSS Selector:
            CSS Selector를 사용하면 CSS 클래스가 
            특정 클래스 내부에 있는 경우에만 스타일을
            적용할 수 있습니다
    2.Sass 사용하기
        -Sass(Syntactically Awesome Style Sheets)
        는 CSS 전처리기로 복잡한 작업을 쉽게 할 수 있도록 
        해 주고, 스타일 코드의 재활용성을 높여 줄 뿐만 아니라
        코드의 가독성을 높여서 유지 보수를 더욱 쉽게 해 줍니다
        - .sass 확장자는 중괄호와 세미콜론을 사용하지
        않습니다 .scss 확장자는 기존 css와 별반 다르지
        않습니다
        -Sass 변수 및 믹스인은 다른 파일로 분리하여 작성한
        뒤 필요한 곳에서 쉽게 불러와 사용할 수 있습니다
        -sass-loader 설정을 커스터마이징하여 복잡한 디레턱리
        구조를 해결할 수 있습니다 이는 yarn eject 명령어를
        통해 사용합니다 
        -Sass의 장점 중 하나는 라이브러리를 쉽게 불러와서
        사용할 수 있다는 점입니다 ~문자를 사용하면
        node_modules에서 자동으로 경로를 찾아
        스타일을 불러옵니다 .scss파일을 불러오면 됩니다
    3.CSS Module
        -CSS Module은 CSS를 불러와서 사용할 떄 클래스
        이름을 [파일이름]_[클래스 이름]_[해시값] 형태로
        자동으로 만들어서 컴포넌트 스타일 클래스 이름이
        중첩되는 현상을 방지해 주는 기술입니다
        -.module.css 확장자로 파일을 저장하면 
        CSS Module이 적용됩니다
        -CSS Module을 사용하면 클래스 이름을 지을때
        그 고유성에 대해 고민하지 않아도 됩니다 해당 
        클래스는 우리가 방금 만든 스타일을 직접 불러온
        컴포넌트 내부에서만 작동하기 때문입니다
        -만약 특정 클래스가 웹 페이지에서 전역적으로
        사용되는 경우라면 :global을 앞에 입력합니다
        -CSS Module이 적용된 스타일 파일을 불러오면
        객체를 하나 전달받게 되는데 CSS Module에서 
        사용한 클래스 이름과 해당 이름을 고유화한 값이
        키-값 형태로 들어 있습니다
        -이 고유한 클래스 이름을 사용하려면 JSX 엘리먼트에
        className={객체.클래스이름} 형태로 전달합니다
        전역적으로 선언한 클래스의 경우 평상시와 같습니다
        -classnames라는 라이브러리로 CSS 클래스를 조건부로
        설정할 수 있습니다
        -Sass를 사용할 때도 파일 이름 뒤에 .module.scss
        확장자를 사용해주면 CSS Module로 사용할 수 있습니다
    
    4.styled-components
        -CSS-in-JS라고 부르는 자바스크립트 파일 안에 스타일을 
        선언하는 방식이 있습니다 CSS-in-JS 라이브러리 중에서
        개발자들이 가장 선호하는 style-components를 알아봅니다
        -자바스크립트 파일 하나에 스타일까지 작성할 수 있기에 .css
        or .scss 확장자를 가진 스타일 파일을 따로 만들지 않아도
        되는 큰 이점이 있습니다

        -Tagged 템플릿 리터럴:
        백턱을 사용하여 만든 문자열을 사용하는 리터럴을 Tagged 템플릿
        리터럴이라고 부릅니다
        일반 템플릿 리터럴과 다른 점은 템플릿 안에 자바스크립트 객체나
        함수를 전달할 때 온전히 추출할 수 있다는 것입니다

        -styled-components를 사용하여 스타일링된 엘리먼트를 만들
        때는 컴포넌트 파일의 상단에서 styled를 불러오고, 
        styled.태그명을 사용하여 구현합니다
            
실제로 앱을 만들때 팁:
    1.map을 사용하여 컴포넌트로 변환할 때는 key props를 전달해 주어야 한다
    2.여러 종류의 값을 전달해야 하는 경우에는 객체로 통쨰로 전달하는 편이
    성능 최적화를 할 때 편하다
    3.useState가 아닌 useRef를 사용하여 컴포넌트 변수를 만드는 이유는
    값이 렌더링되는 정보가 아닌 경우입니다. 값이 화면에 보이지도 않고
    값이 바뀐다고 해서 컴포넌트가 리렌더링될 필요도 없을 때 사용합니다
    4.props로 전달해야 할 함수를 만들 때는 useCallback을 사용하여 
    함수를 감싸는 것을 습관화합니다
    5.e.preventDefaut()를 통해 새로고침을 방지할 수 있습니다
    6.리액트 컴포넌트에서 배열의 불변성을 지키면서 배열 원소를 
    제거해야 할 경우, 배열 내장 함수인 filter를 사용하면 간편합니다
    7.filter() 함수는 기존의 배열을 그대로 둔 상태에서 특정 조건을
    만족하는 원소들만 따로 추출하여 새로운 배열을 만들어 줍니다
    8.map을 사용하여 특정 id를 가지고 있는 객체의 값을 바꿀 수 있습니다
    불변성을 유지하면서 특정 배열 원소를 업데이트할 때 map을 사용하면 짧은
    코드로 쉽게 작성할 수 있습니다

컴포넌트 성능 최적화:
    느려지는 원인 분석:
        컴포넌트는 다음과 같은 상황에서 리렌더링이 발생합니다.
        1.자신이 전달받은 props가 변경될 때
        2.자신의 state가 바뀔 때
        3.부모 컴포넌트가 리렌더링될 때
        4.forceUpdate 함수가 실행될 때
        성능 최적화를 위해 리렌더링입 불필요할 때는 리렌더링을 방지합니다

    React.memo를 사용한 컴포넌트 성능 최적화:
        컴포넌트의 리렌더링을 방지할 때는 shouldComponentUpdate라는 
        라이프사이클을 사용하면 됩니다. 그런데 함수형 컴포넌트에서는 
        라이프사이클 메서드를 사용할 수 없습니다.그 대신 React.memo라는 
        함수를 사용합니다. 컴포넌트의 props가 바뀌지 않았다면, 리렌더링하지
        않도록 설정하여 함수형 컴포넌트의 리렌더링 성능을 최적화할 수 있습니다
        React.memo 사용법은 매우 간단합니다. 컴포넌트를 만들고 나서
        감싸 주기만 하면 됩니다 export default React.memo(컴포넌트);

    onToggle, onRemove 함수가 바뀌지 않게 하기:
        React.memo를 사용하는 것만으로 컴포넌트 최적화가 끝나지 않습니다.
        함수가 계속 만들어지는 상황을 방지할 수 없기 때문입니다.
        이런 상황을 방지하기 위한 방법은 두 가지입니다.
        첫 번째 방법은 useState의 함수형 업데이트 기능을 사용하는 것이고,
        두 번째 방법은 useReduce를 사용하는 것입니다.

        -useState의 함수형 업데이트:
        기존에 set 함수를 사용할 때는 새로운 상태를 파라미터로 넣어 주었습니다.
        set 함수를 사용할 때 새로운 상태를 파라미터로 넣는 대신, 상태 업데이트를
        어떻게 할지 정의해 주는 업데이트 함수를 넣을 수도 있습니다. 이를
        함수형 업데이트라고 부릅니다.

        -useReducer 사용:
        상태를 업데이트 하는 로직을 모아서 컴포넌트 바깥에 둘 수 있다는 장점이
        있습니다. 

    불변성의 중요성:
        리액트 컴포넌트에서 상태를 업데이트할 때 불변성을 지키는 것은 
        매우 중요합니다. 업데이트가 필요한 곳에서는 아예 새로운 배열
        혹은 새로운 객체를 만들기 때문에, React.memo를 사용했을 때
        props가 바뀌었는지 혹은 바뀌지 않았는지를 알아내서 리렌더링
        성능을 최적화해 줄 수 있습니다. 이렇게 기존의 값을 수정하지 않으면서
        새로운 값을 만들어 내는 것을 '불변성을 지킨다' 라고 합니다.
        불변성이 지켜지지 않으면 객체 내부의 값이 새로워져도 바뀐 것을
        감지하지 못합니다. 그러면 React.memo에서 서로 비교하여 최적화하는 것이
        불가능합니다
        추가로 전개 연산자(...)를 사용하여 객체나 배열 내부의 값을
        복사할 때는 얕은 복사를 하게 됩니다. 즉, 내부의 값이 완전히
        새로 복사되는 것이 아니라 가장 바깥쪽에 있는 값만 복사됩니다.
        따라서 내부의 값이 객체 혹은 배열이라면 내부의 값 또한 따로 복사해 주어야합니다
        ex) const todos = [{id: 1, checked: true}, 
                            {id:2, checked: true}];
            const nextTodos = [...todos];
            nextTodos[0].checked = false;
            todos[0] === nextTodos[0] //똑같은 객체를 가르킴 true
        배열 혹은 객체의 구조가 정말 복잡해진다면 이렇게 불변성을 유지하면서
        업데이트하는 것도 까다로워집니다. 이럴 때는 immer라는 라이브러리의 
        도움을 받는 것이 좋습니다

    List 컴포넌트 최적화하기:
        리스트에 관련된 컴포넌트를 최적화할 때는 리스트 내부에서 사용하는 컴포넌트도
        최적화해야 하고, 리스트로 사용되는 컴포넌트 자체도 최적화해 주는 것이 좋습니다
        그러나 내부 데이터가 100개를 넘지 않거나 업데이트가 자주 발생하지 않는다면,
        이런 최적화 작업을 반드시 해 줄 필요는 없습니다.

    react-virtualized를 사용한 렌더링 최적화:
        리렌더링 성능을 최적화할 때는 필요할 때만 리렌더링하도록 설정해 주었습니다.
        이번에는 또 다른 렌더링 성능 최적화 방법을 알아보겠습니다.
        react-virtualized를 사용하면 리스트 컴포넌트에서 스크롤되기 전에
        보이지 않는 컴포넌트는 렌더링하지 않고 크기만 차지하게끔 할 수 있습니다.
        그리고 만약 스크롤되면 해당 스크롤 위치에서 보여 주어야할 컴포넌트를
        자연스럽게 렌더링시킵니다. 
        최적화를 수행하려면 사전에 먼저 해야 하는 작업이 있는데, 바로 각 항목의
        실제 크기를 px 단위로 알아내는 것입니다.

immer를 사용하여 더 쉽게 불변성 유지하기:
    객체의 구조가 깊어지면 불변성을 유지하면서 업데이트하기가 힘들어 집니다.
    이 떄 immer를 이용해 더 쉽게 불변성을 유지합니다.
    이 라이브러리의 핵심은 '불변성에 신경 쓰지 않는 것처럼 코드를 작성하되
    불변성 관리는 제대로 해 주는 것' 입니다.
    immer를 사용할 때는 객체의 값을 직접 수정하거나 배열에 직접적인
    변화를 일으키는 함수를 써도 무방합니다.


리액트 라우터로 SPA 개발하기:
    SPA란?
        SPA는 Single Page Application의 약어입니다. 말 그대로 한 개의
        페이지로 이루어진 애플리케이션이라는 의미입니다. 
        전통적인 웹 페이지는 여러 페이지로 구성되어 있습니다. 사용자가 다른 페이지로
        이동할 때마다 새로운 html을 받아 오고, 페이지를 로딩할 때마다 서버에서
        리소스를 전달받아 해석한 뒤 화면에 보여 주었습니다. 요즘은 웹에서 제공되는
        정보가 정말 많기 때문에 새로운 화면을 보여 주어햐 할때마다 서버 측에서 모든
        뷰를 준비한다면 성능상의 문제가 발생할 수 있습니다.
        그래서 리액트 같은 라이브러리 혹은 프레임워크를 사용하여 뷰 렌더링을 사용자의
        브라우저가 담당하도록 하고, 우선 애플리케이션을 브라우저에 불러와서 실행시킨
        후에 사용자와의 인터랙션이 필요한 부분만 자바스크립트를 사용하여 업데이트를
        해 줍니다. 새로운 데이터가 필요하면 서버 api를 호출해서 필요한 데이터만
        불러옵니다.
        SPA의 경우 서버에서 사용자에게 제공하는 페이지는 한 종류이지만, 해당 
        페이지에서 로딩된 자바스크립트와 현재 사용자 브라우저의 주소 상태에 따라
        다양한 화면을 보여 줄 수 있습니다.
        다른 주소에 다른 화면을 보여주는 것을 라우팅이라고 합니다. 리액트 자체에
        이 기능이 내장되어 있지는 않습니다. 그 대신 라이브러리를 사용하거나 브라우저의
        API를 직접 사용합니다. 
        
        SPA의 단점으로 앱의 규모가 커지면 자바스크립트 파일이 너무 커진다는 것입니다.
        페이지 로딩 시 사용자가 실제로 방문하지 않을 수도 있는 페이지의 스크립트도
        불러오기 때문이죠. 이는 코드 스플리팅을 통해 라우트별로 파일들을 나누어
        트래픽과 로딩 속도를 개선할 수 있습니다.
        자바스크립트를 사용하여 라우팅을 관리하는 것은 자바스크립트를 실행하지 않는
        일반 크롤러에서는 페이지의 정보를 제대로 수집해 가지 못한다는 잠재적인 단점이
        있습니다. 이러한 문제점은 서버 사이드 렌더링을 통해 모두 해결할 수 있습니다.

    Link 컴포넌트를 사용하여 다른 주소로 이동하기:
        Link 컴포넌트는 클릭하면 다른 주소로 이동시켜 주는 컴포넌트입니다.
        리액트 라우터를 사용할 때는 <a> 태그를 직접 사용하면 안 됩니다.
        이 태그는 페이지를 전환하는 과정에서 페이지를 새로 불러오기 때문에
        애플리케이션이 들고 있던 상태들을 모두 날려 버리게 됩니다.
        Link 컴포넌트를 사용하여 페이지를 전환하면, 페이지를 새로 불러오지 않고
        애플리케이션은 그대로 유지한 상태에서 HTML5 History API를 사용하여
        페이지의 주소만 변경해 줍니다. Link 컴포넌트 자체는 a 태그로 이루어져 있지만,
        페이지 전환을 방지하는 기능이 내장되어 있습니다.

    Route 하나에 여러 개의 path 설정하기: //deprecated
        path props를 배열로 설정해 주면 여러 경로에서 같은 컴포넌트를 보여줍니다

    URL 파라미터와 쿼리:
        페이지 주소를 정의할 때 가끔은 유동적인 값을 전달해야 할 때도 있습니다.
        이는 파라미터와 쿼리로 나눌 수 있습니다.
        /* deprecated 
        URL 파라미터를 사용할 때는 라우트로 사용되는 컴포넌트에서 받아 오는 
        match라는 객체 안의 params 값을 참조합니다. match 객체 안에는
        현재 컴포넌트가 어떤 경로 규칙에 의해 보이는 지에 대한 정보가 있습니다. */
        v6 이후부터는 useParams를 사용해 받아와야 한다

        // deprecated
        URL 쿼리는 location 객체에 들어있는 search 값에서 조회합니다
        search는 문자열로 되어 있으며 특정 값을 객체 형태로 변환해 주어야 합니다//
        useLocation을 사용합니다 그럼 location 객체를 뱉어냅니다.

비동기 작업의 이해:
    서버의 API를 사용할 때는 네트워크 송수신 과정에서 시간이 걸리기 때문에 작업이
    즉시 처리되는 것이 아니라, 응답을 받을 때까지 기다렸다가 전달받은 응답 데이터를
    처리합니다. 이 과정에서 해당 작업을 비동기적으로 처리하게 됩니다.
    작업을 동기적으로 처리한다면 요청이 끝날 때까지 기다리는 동안 중지 상태가
    되기 때문에 다른 작업을 할 수 없습니다. 하지만 이를 비동기적으로 처리한다면
    웹 애플리케이션이 멈추지 않기 때문에 동시에 여러 가지 요청을 처리할 수도 있고,
    기다리는 과정에서 다른 함수도 호출할 수 있습니다. 
    자바스크립트에서 비동기 작업을 할 때 흔히 사용하는 방법이 콜백 함수를 
    사용하는 것입니다. 콜백 안에 또 콜백을 넣어서 구현할 수 있는데, 너무
    여러 번 중첩되면 가독성이 떨어져 콜백 지옥이라고 부릅니다. 
    이러한 콜백 지옥을 형성하지 않기 위해 Promise 기능이 만들어졌습니다.
    .then을 사용하여 그 다음 작업을 설정하기 때문에 콜백 지옥이 형성되지 않습니다.
    async/await라는 문법을 통해 Promise를 더욱 쉽게 사용할 수 있습니다.

    axios: 현재 가장 많이 사용되고 있는 자바스크립트 HTTP 클라이언트 입니다.
            이 라이브러리의 특징은 HTTP 요청을 Promise로 처리합니다.
        