yarn create react-app <project-name> :
    리액트 프로젝트 생성

Reactjs code Snippet:
    rsc : 함수형 컴포넌트 생성
    rcc : 클래스형 컴포넌트 생성

JSX 문법 :
    1.감싸인 요소
        -컴포넌트에 여러 요소가 있다면, 부모 요소 하나로 감싸야한다.
        이 떄 <div>와 <Fragment>, <> (Fragment의 다른 형태)를 쓸 수 있다.

    2.자바스크립트 표현
        -자바스크립트 표현을 쓰고 싶다면 JSX내부에서 코드를 {}로 감싸면 된다.
        -ES6의 const와 let
            const는 변경이 불가능한 상수
            let은 동적인 값을 담을 수 있는 변수
            var는 scope(해당 값을 사용할 수 있는 코드 영역)가 함수 단위
            let과 const는 scope가 블록 단위

    3.if문 대신 조건부 연산자 (삼항연산자)
        -jsx에서는 if문 사용 불가
        -{} 안에 조건부 연산자를 사용
        -&&를 이용한 조건부 연산이 가능한 이유는 리액트는 false와 null를 렌더링할 때
        아무것도 나타나지 않음

    note:
        jsx는 괄호로 감싸는 것이 필수사항이 아님 감싸도 되고 안 감싸도 된다

    4.undefined를 렌더링하지 않기
        -리액트 컴포넌트에서는 undefined만 반환하여 렌더링하는 상황을 만들면 안된다
        -어떤 값이 undefined일 수도 있다면 or 연산자를 사용한다
        -jsx내부에서 undefined를 렌더링하는 것은 괜찮다
    
    5.인라인 스타일링
        - 스타일 이름 중에 -가 포함되어있다면 (background-color) -> backgroundColor
        로 카멜표기법을 이용해 바꾸어 준다.
        -style 객체를 미리 선언하고 div의 style={스타일 객체}를 넣어주는 방법과
        바로 객체로 넣어주는 방법이 있다
    
    6.class대신 className
        -html에서 css클래스를 사용할 때는 <div class="name"></div>와 같이 
        사용했다면, jsx에서는 class가 아닌 className을 써줘야 한다.
    
    7.꼭 닫아야 하는 태그
        -html에서는 태그를 닫지 않아도 오류를 출력하지 않고 자동으로 처리해주지만,
        리액트에서는 태그를 꼭 닫아줘야 한다.

    8.주석
        -JSX는 javascript와 달리 주석을 작성할 때는 {/*...*/}와 같은 형식으로 작성
        합니다. 시작태그를 여러 줄로 작성하게 되면 //으로 작성할 수도 있습니다.

ES6 문법:
    1.화살표 함수
        -이 문법은 주로 함수를 파라미터로 전달할 때 유용합니다.
        -이 문법은 기존 function을 대체 불가능합니다. 서로 가르키고 있는 this값이
        다르기 때문입니다.
        - () => { 함수 내 선언문; } 형식으로 사용하며 {}를 열어주지 않을시 연산값을
        그대로 반환합니다.
        - 함수형 컴포넌트를 사용할 때는 function과 화살표을 쓰는 것에 큰 차이가 없습니다
    
    2.비구조화 할당 문법
        -객체에서 값을 추출하는 문법을 비구조화 할당이라고 부릅니다.
        -const {name, children} = props 이런 식으로 할당할 수 있습니다.
        -함수의 파라미터에서도 사용 가능합니다.
        -배열은 const [one, two] = array 이런 식으로 사용합니다


컴포넌트 :
    1.선언
        -컴포넌트를 선언하는 방식은 두 가지로 하나는 함수형 컴포넌트, 또 다른 하나는 
        클래스형 컴포넌트입니다.
        -둘의 차이는 클래스형 컴포넌트의 경우 state 기능과 라이프사이클 기능을 사용할 수
        있다는 것과 임의 메서드를 정의할 수 있다는 것입니다.
        -클래스형 컴포넌트는 render함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할
        JSX를 반환해야 합니다.
        -함수형 컴포넌트의 장점은 선언하기 편하고, 메모리 자원도 덜 사용합니다.
        -함수형 컴포넌트는 Hooks를 사용해 클래스형과 비슷하게 사용 가능합니다.
    
    2.모듈 내보내기 및 불러오기
        -export는 다른 파일에서 이 파일을 임포트할 때 줄 클래스를 선언합니다.
        -import는 다른 파일에서 파일을 불러올 때 쓸 클래스를 선언합니다.
    
    3.props
        -props는 properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는
        요소입니다.
        -props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정할 수 있습니다
        -props 기본값 설정은 defaultProps로 합니다
        -부모 컴포넌트의 태그 사이의 내용은 children으로 들어갑니다
    
    4.propTypes를 통한 검증
        -propTypes를 통해 prop의 타입을 강제하거나 필수 prop을 정할 수 있습니다.
        -isRequired를 통해 필수 prop을 설정합니다
        -PropTypes 종류:
            array, arrayOf(다른 PropType) : 특정 PropType으로 이루어진 배열,
            bool, func, number, object, string, symbol, node,
            instanceOf(클래스), oneOf([]): 배열 요소 중 값 하나,
            oneOfType([]): 주어진 배열 안의 종류 중 하나, any
    
    5.클래스형 컴포넌트에서 props 사용
        -클래스형 컴포넌트에서는 render 함수에서 this.props를 조회하면 됩니다.
        -defaultProps와 propTypes를 클래스 내부에서 저장하는 방법도 있습니다
        -defaultProps와 propTypes는 다른 개발자들과 협업할 때, 컴포넌트에 어떤 
        prop이 필요한지 쉽게 알려줍니다.

    6.state
        -두 가지 종류의 state가 있습니다. 하나는 클래스형 컴포넌트가 가지고 있는
        state이고, 다른 하나는 함수형 컴포넌트에서 useState()라는 함수를 통해 사용하는
        state입니다.
        -클래스형 컴포넌트의 state:
            *컴포넌트의 생성자 메소드를 작성하고 반드시 super(props)를 호출해주세요
            *컴포넌트의 state는 객체 형식이어야 합니다
            *render 함수에서 현재 state를 조회할 때는 this.state를 조회하면 됩니다
            *생성자 메소드 없이 state = {값}으로 초기값을 지정할 수 있습니다
        -this.setState()로 state를 바꿀 수 있습니다 이 때 인자로 객체와 함수를 줄
        수 있습니다 함수를 줄 때는 (prevState, props)를 줄 수 있습니다 prevState는
        기존 상태이고 props는 현재 지니고 있는 props를 가르킵니다
        -this.setState가 끝난 후 특정 작업 실행하려면 두번째 인자로 특정 작업을 실행하는
        콜백함수를 등록합니다
        -useState 함수의 인자에는 상태의 초기값을 넣어줍니다. 값의 형태는 자유입니다.
        함수를 호출하면 배열이 반환되는데, 첫번째 원소는 현재 상태이고, 두 번째 원소는
        상태를 바꾸어주는 함수입니다. 이 함수를 setter라고 부릅니다. 원소를 받을 때
        비구조화 할당을 쓸 수 있습니다.
        -useState는 한 컴포넌트에서 여러번 사용해도 상관없습니다.
        -state를 사용할 때 주의 사항:
            state 값을 바꿔야 할 때는 setState 혹은 useState를 통해 전달받은
            세터 함수를 사용해야 합니다
            배열이나 객체를 업데이트 해야할 때는 사본을 만들고 그 사본의 상태를
            세터함수를 통해 업데이트합니다
        -앞으로 새로운 컴포넌트를 만들 때는 useState를 사용할 것을 권장합니다
        코드가 간결해지고 개발 팀에서 Hooks를 사용하는 것이 주가 될 것이라고 발표했기
        때문입니다

이벤트 핸들링:
    1.이벤트를 사용할 때 주의사항
        -이벤트 이름은 카멜 표기법으로 작성합니다
        -이벤트에 실행할 자바스크립트를 전달하는 것이 아니라, 함수 형태의 값을 전달합니다
        -DOM 요소에만 이벤트를 설정할 수 있습니다 컴포넌트에 자체적으로 이벤트를 설정할 수
        는 없습니다 하지만 전달받은 props를 컴포넌트 내부의 DOM 이벤트로 설정할 수는 있죠
    2.임의 메서드 만들기
        -임의 메소드가 이벤트로 등록되어도 this를 컴포넌트 자신으로 제대로 가르키기 위해서
        는 메소드를 this와 바인딩하는 작업이 필요합니다 이를 위해 constructor 함수에서
        함수를 바인딩합니다
        -메소드 바인딩은 생성자 메소드에서 하는 것이 정석입니다만, 이 작업이 불편합니다
        이를 대체해 바벨의 transform-class-properties 문법을 사용하여 
        화살표 함수 형태로 메소드를 정의합니다
    3.input 여러개 다루기
        -input이 여러 개일 때는 메소드도 여러 개 만들어 작업할 수도 있지만, 더 쉽게
        처리하는 방법이 있습니다 event 객체를 활용하는 것 입니다
        -e.target.name은 input의 name을 가르킵니다
        -객체 안에 key를 [ ]로 감싸면 그 안에 넣은 레퍼런스가 가르키는 실제 값이
        key 값으로 사용됩니다
    4.함수형 컴포넌트
        -useState를 통해 클래스형과 똑같이 다룰 수 있습니다

ref:
    1.ref란?
        -ref는 리액트 프로젝트 내부에서 DOM에 이름을 다는 방법입니다 DOM의 id와 비슷합니다
        -id를 사용할 수도 있습니다만, 권장하지는 않습니다 같은 컴포넌트를 여러번 사용하다보면
        id가 유일해지지 않기 때문입니다 ref는 전역적으로 작동하지 않기 때문에 이런 문제가
        생기지 않습니다
    2.어떤 상황에서 ref를 사용하는가
        -DOM을 꼭 직접적으로 건드려야 할 때 사용합니다
        -DOM을 꼭 사용해야 하는 상황
            특정 input에 포커스 주기
            스크롤 박스 조작하기
            Canvas 요소에 그림 그리기 등
    3.ref 사용
        -콜백 함수를 통한 ref 설정: ref를 달고자 하는 요소에 ref라는 콜백 함수를 
        props로 전달해 줍니다 그리고 함수 내부에서 파라미터로 받은 ref를 컴포넌트의
        멤버 변수로 설정해 줍니다
        -createRef를 통한 ref 설정: 리액트에 내장되어 있는 createRef라는 함수를
        사용합니다 설정한 뒤 나중에 ref를 설정해 준 DOM에 접근하려면 this.input.
        current를 조회합니다
    4.컴포넌트에 ref 달기
        -이 방법은 주로 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 씁니다
        컴포넌트에 ref를 다는 방법은 DOM에 ref를 다는 방법과 같습니다
        -사용법 <MyComponent ref={(ref)=>{this.myComponent = ref}}/>
        -이렇게 하면 MyComponent 내부의 메소드 및 멤버 변수에도 접근 가능합니다
    5.ref를 사용할 때 주의할 점
        -서로 다른 컴포넌트끼리 데이터를 교류할 때 ref를 사용하지 않습니다
        사용할 수는 있지만, 유지보수 문제 때문에 사용하지 않습니다

컴포넌트 반복:
    1.배열의 map() 함수: arr.map(callback, [thisArg])
        callback: 새로운 배열의 요소를 생성하는 함수로 파라미터는 다음 세 가지입니다
            -currentValue: 현재 처리하고 있는 요소
            -index: 현재 처리하고 있는 요소의 index 값
            -array: 현재 처리하고 있는 원본 배열
        thisArg(선택항목) : callback 함수 내부에서 사용할 this 레퍼런스
    2.key
        -리액트에서 key는 컴포넌트 배열을 렌더링했을 때 어떤 원소에 변동이 있었는지
        알아내려고 사용합니다 key가 없을 때는 Virtual DOM을 비교할 때 순차적으로
        비교합니다 key가 있을때는 어떤 변화가 일어났는지 더욱 빠르게 알아낼 수
        있습니다
        -key 값을 설정할 때는 map 함수의 인자로 전달되는 함수 내부에서 
        컴포넌트 props를 설정하듯이 설정하면 됩니다 key 값은 유일해야 합니다
        -고유한 값이 없을 때는 index 값을 key로 사용해야 합니다 
        index를 key로 사용하면 배열이 변경될 때 효율적으로 리렌더링하지 
        못합니다
    3.리액트 상태 업데이트
        -리액트에서 상태를 업데이트할 때는 기존 상태를 그대로 두면서 새로운 값을
        상태로 설정해야 합니다 이를 불변성 유지라고 합니다 불변성 유지를 해주어야
        리액트 컴포넌트의 성능을 최적화할 수 있습니다
        -이를 위해 배열에 추가할 때는 concat을 사용하고 삭제할 때는 filter를
        써줍니다

컴포넌트의 라이프사이클 메소드:
    1.라이프사이클 메소드의 이해
        -모든 리액트 컴포넌트에는 라이프사이클이 존재합니다
        컴포넌트의 수명은 페이지에 렌더링되기 전인 준비 과정에서 시작하여 페이지
        에서 사라질 때 끝납니다
        -라이프사이클 메소드는 클래스형 컴포넌트에서만 사용할 수 있습니다 
        함수형 컴포넌트에서는 Hooks 기능을 사용하여 비슷하게 처리합니다
        -라이프사이클 메소드의 종류는 총 아홉 가지입니다
        -Will 접두사가 붙은 메소드는 어떤 작업을 작동하기 전에 실행되는 메소드
        이고 Did 접두사가 붙은 메소드는 어떤 작업을 작동한 후에 실행됩니다
        -라이프사이클은 총 세가지, 마운트, 업데이트, 언마운트로 나눕니다
    2.마운트
        -DOM이 생성되고 웹 브라우저 상에 나타나는 것을 mount라고 합니다
        이 떄 호출하는 메소드는 다음과 같습니다
            컴포넌트 만들기 -> constructor -> getDerivedStateFromProps
            -> render -> componentDidMount
        constructor: 컴포넌트를 새로 만들 때마다 호출되는 클래스 생성자 메소드
        getDerivedStateFromProps: props에 있는 값을 state에 넣을 때
                                사용하는 메소드
        render: 우리가 준비한 UI를 렌더링하는 메소드
        componentDidMount: 컴포넌트가 웹 브라우저에 나타난 후 호출하는 메소드
    3.업데이트
        -컴포넌트는 다음과 같은 총 네가지 경우에 업데이트합니다
            1.props가 바뀔 때
            2.state가 바뀔 때
            3.부모 컴포넌트가 리렌더링될 때
            4.this.forceUpdate로 강제로 렌더링을 트리거할 때
        업데이트할 때 호출되는 메소드는 다음과 같습니다
            업데이트 발생 -> getDerivedStateFromProps ->
            shouldComponentUpdate(false반환 시 여기서 작업 취소)
             -> render (true반환시) -> getSnapshotBeforeUpdate
             -> 웹 브라우저상의 실제 DOM 변화 -> componentDidUpdate
        shouldComponentUpdate : 컴포넌트가 리렌더링을 해야 할지
        말아야 할지를 결정하는 메소드입니다 만약, 특정 함수에서 
        this.forceUpdate() 함수를 호출하면 이 과정을 생략합니다
        getSnapshotBeforeUpdate : 컴포넌트 변화를 DOM에 반영하기 바로 전에
                                호출하는 메소드
        componentDidUpdate : 컴포넌트의 업데이트가 끝나고 호출하는 메소드
    4.언마운트
        -마운트의 반대 과정, 즉 컴포넌트를 DOM에서 제거하는 것을 가르킵니다
            언마운트하기 -> componentWillUnmount
        componentWillUnmount : 컴포넌트가 웹 브라우저상에서 사라지기 전에
                            호출하는 메소드입니다
    5.render() 함수
        -이 메소드는 컴포넌트의 모양새를 정의합니다 라이프사이클 메소드 중
        유일한 필수 메소드입니다
        -이 메소드 안에서 this.props와 this.state에 접근할 수 있으며,
        리액트 요소를 반환합니다
        -이 메소드 안에서는 이벤트 설정이 아닌 곳에서 setState를 사용해서는
        안되며, 브라우저 DOM에 접근해서도 안됩니다
        -DOM 정보를 가져오거나 state에 변화를 줄 떄는 componentDidMount에서
        처리해야 합니다

    6. constructor 메소드
        -컴포넌트의 생성자 메소드로 컴포넌트를 만들 때 처음으로 실행됩니다
        이 메소드에서는 초기 state를 정할 수 있습니다

    7.getDerivedStateFromProps 메소드
        -props로 받아 온 값을 state에 동기화시키는 용도로 사용하며, 
        컴포넌트가 마운트될 떄와 업데이트될 때 호출됩니다

    8.componentDidMount 메소드
        -컴포넌트를 만들고, 첫 렌더링을 마친 후 실행합니다
        -이 안에서 다른 자바스크립트 라이브러리 또는 프레임워크의 함수를
        호출하거나 이벤트 등록, setTimeout, setInterval, 네트워크
        요청 같은 비동기 작업을 처리하면 됩니다

    9.shouldComponentUpdate 메소드
        -props 또는 state를 변경했을 때, 리렌더링을 시작할지 여부를 정하는 메소드
        -이 메소드에서는 반드시 true 값 또는 false 값을 반환해야 합니다
        -컴포넌트를 만들 때 이 메소드를 따로 생성하지 않으면 기본적으로 true를 
        반환합니다 false를 반환할 시 업데이트 과정을 여기서 중지됩니다
        -이 메소드 안에서 현재 props와 state는 this.props와 this.state로 
        접근하고, 새로 생성될 것은 nextProps와 nextState로 접근합니다

    10.getSnapshotBeforeUpdate 메소드
        -이 메소드는 render에서 만들어진 결과물이 브라우저에 반영되기 직전에 
        호출됩니다
        -이 메소드의 반환 값은 componentDidUpdate에 세 번째 파라미터인
        snapshot 값으로 전달받을 수 있는데, 주로 업데이트하기 직전의 값을
        참고할 일이 있을 때 활용됩니다 (예: 스크롤바 위치 유지)

    11. componentDidUpdate 메소드
        -리렌더링을 완료한 후 실행됩니다 업데이트가 끝난 직후이므로,
        DOM 관련 처리를 해도 무방합니다
        -여기서 prevProps 또는 prevState를 사용하여 컴포넌트가
        이전에 가졌던 데이터에 접근할 수 있습니다

    12. componentWillUnmount 메소드
        -컴포넌트를 DOM에서 제거할 때 실행합니다 componentDidMount에서 
        등록한 이벤트, 타이머, 직접 생성한 DOM이 있다면 여기서 제거해야 합니다

    13. componentDidCatch 메소드
        -컴포넌트 렌더링 도중에 에러가 발생했을 때 에플리케이션이 먹통이
        되지 않고 오류 UI를 보여줄 수 있게 합니다 
        -컴포넌트 자신에게 발생하는 에러를 잡아낼 수 없고 자신의 
        this.props.children으로 전달되는 컴포넌트에서 발생하는 에러만
        잡아낼 수 있다는 점을 알아두어야 합니다

Hooks : 
    1.Hooks란?
        -함수형 컴포넌트에서도 상태 관리를 할 수 있는 useState, 렌더링 
        직후 작업을 설정하는 useEffect 등의 기능을 제공하여 기존의 함수형
        컴포넌트에서 할 수 없었던 다양한 작업을 할 수 있게 해 줍니다.  

    2.useState
        -가장 기본적인 Hook이며, 함수형 컴포넌트에서도 가변적인 상태를
        지닐 수 있게 해줍니다.
        -파라미터에는 상태의 기본값을 넣어줍니다
        -배열을 반환합니다 그 배열의 첫 번째 원소는 상태 값, 두 번째 원소는
        상태를 설정하는 함수입니다
        -하나의 useState 함수는 하나의 상태 값만 관리할 수 있습니다 
        컴포넌트에서 관리해야 할 상태가 여러개라면 useState를 여러 번 사용합니다

    3.useEffect
        -리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수
        있는 Hook입니다 
        -클래스형 컴포넌트의 componentDidMount와 componentDidUpdate를
        합친 형태로 보아도 무방합니다
        -마운트될 때만 실행하고 싶다면 두 번째 파라미터로 [] 빈 배열을
        넣어주면 됩니다
        -특정 값이 업데이트될 때만 실행하고 싶다면 두 번째 파라미터로 전달되는
        배열 안에 검사하고 싶은 값을 넣어주면 됩니다
        -언마운트 되기 전이나 업데이트 되기 직전에 어떠한 작업을 수행하고
        싶다면 뒷정리 함수를 반환해 주어야 합니다
        -언마운트될 때만 뒷정리 함수를 호출하고 싶다면 두번째 파라미터에
        비어 있는 배열을 넣으면 됩니다

    4.useReducer
        -useState보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른
        값으로 업데이트할 때 쓰는 Hook입니다
        -리듀서는 현재 상태, 그리고 업데이트를 위해 필요한 정보를 담은
        액션 값을 전달받아 새로운 상태를 반환하는 함수입니다 리듀서 함수
        에서 새로운 상태를 만들 때는 반드시 불변성을 지켜 주어야 합니다
        -액션 값은 다음과 같은 형태입니다
            {
                type: 'INCREMENT',
                //다른 값들이 필요하다면 추가로 들어감
            }
        -액션 객체는 반드시 type을 지니고 있을 필요가 없습니다 심지어,
        객체가 아니라 문자열이나 숫자여도 상관없습니다
        -useReducer의 첫번째 파라미터에는 리듀서 함수를 넣고,
        두 번째 파라미터에는 해당 리듀서의 기본값을 넣어줍니다
        -이 Hook을 사용하면 state값과 dispatch함수를 받아옵니다
        -state는 현재 가르키고 있는 상태이고, dispatch는 액션을
        발생시키는 함수입니다
        -dispatch(action)과 같은 형태로, 함수 안에 파라미터로 액션
        값을 넣어주면 리듀서 함수가 호출되는 구조입니다
        -useReducer의 가장 큰 장점은 컴포넌트 업데이트 로직을 
        컴포넌트 바깥으로 빼낼 수 있다는 것입니다
    
    5.useMemo
        -함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있습니다
        -중복 생성되는 연산을 한번으로 줄일 수 있습니다

    6.useCallback
        -useMemo와 비슷한 함수로 주로 렌더링 성능을 최적화해야 하는
        상황에서 사용합니다 이 Hook을 사용하면 이벤트 핸들러 함수를
        필요할 때만 생성할 수 있습니다
        -컴포넌트의 렌더링이 자주 발생하거나 렌더링해야 할 컴포넌트의
        개수가 많아지면 이 부분을 최적화해 주는 것이 좋습니다
        -useCallback의 첫 번째 파라미터에는 생성하고 싶은 함수를
        넣고, 두 번째 파라미터에는 배열을 넣으면 됩니다 이 배열에는
        어떤 값이 바뀌었을 때 함수를 새로 생성해야 하는지 명시해야
        합니다
        -비어있는 배열을 넣게 되면 컴포넌트가 렌더링될 떄 단 한번만
        함수가 생성되며, 값을 넣으면 그 값이 변경될 때마다 함수가
        생성됩니다
        -함수 내부에서 상태 값에 의존해야 할 때는 그 값을 반드시
        두 번째 파라미터 안에 포함시켜 주어야 합니다
        -숫자,문자열,객체처럼 일반 값을 재사용하려면 useMemo를,
        함수를 재사용하려면 useCallback을 사용합니다

    7.useRef
        -함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해줍니다
        -로컬 변수를 사용해야 할 때도 useRef를 활용할 수 있습니다
        로컬 변수란 렌더링과 상관없이 바뀔 수 있는 값을 의미합니다

    8.커스텀 Hooks
        -새로운 파일을 만들어 새로운 Hook을 만들 수 있습니다
    
    9.정리
        -메뉴얼에서는 새로 작성하는 컴포넌트의 경우 함수형 컴포넌트와
        Hooks를 사용하길 권장합니다

컴포넌트 스타일링:
    리액트에서 컴포넌트를 스타일링할 때는 다양한 방식을 사용할 수 있습니다
    여러 방식 중에서 딱히 정해진 방식은 없습니다
    스타일링 방식은 다음과 같습니다
    -일반 CSS : 컴포넌트를 스타일링하는 가장 기본적인 방식입니다
    -Sass: 자주 사용되는 CSS 전처리기 중 하나로 확정된 CSS 문법을
            사용하여 CSS 코드를 더욱 쉽게 작성할 수 있도록 해줍니다
    -CSS Module : 스타일을 작성할 때 CSS 클래스가 다른 CSS 클래스의
                이름과 절대 충돌하지 않도록 파일마다 고유한 이름을 
                자동으로 생성해 주는 옵션입니다
    -styled-components: 스타일을 자바스크립트 파일에 내장시키는
                    방식으로 스타일을 적용함과 동시에 해당 스타일이
                    적용된 컴포넌트를 만들 수 있게 해 줍니다
    
    1.가장 흔한 방식, 일반 CSS:
        -새로운 기술을 배울 필요가 없다고 생각되면, 일반 CSS를 
        사용해도 상관없습니다
        -CSS를 작성할 때 가장 중요한 점은 CSS 클래스를 중복되지
        않게 만드는 것입니다
        -중복되는 것을 방지하는 여러 가지 방식이 있는데, 그 중
        하나는 이름을 지을 때 특별한 규칙을 사용하여 짓는 것이고,
        다른 하나는 CSS Selector를 활용하는 것입니다
        -이름 짓는 규칙:
            클래스 이름에 컴포넌트 이름을 포함시킴으로써 다른
            컴포넌트에서 실수를 줄일 수 있습니다
            비슷한 방식으로 BEM 네이밍이라는 방식이 있습니다
            BEM 네이밍은 CSS 방법론 중 하나로, 이름을 
            지을 때 일종의 규칙을 준수하여 해당 클래스가
            어디에서 어떤 용도로 사용되는지 명확하게
            작성하는 방식입니다
        -CSS Selector:
            CSS Selector를 사용하면 CSS 클래스가 
            특정 클래스 내부에 있는 경우에만 스타일을
            적용할 수 있습니다
    2.Sass 사용하기
        -Sass(Syntactically Awesome Style Sheets)
        는 CSS 전처리기로 복잡한 작업을 쉽게 할 수 있도록 
        해 주고, 스타일 코드의 재활용성을 높여 줄 뿐만 아니라
        코드의 가독성을 높여서 유지 보수를 더욱 쉽게 해 줍니다
        - .sass 확장자는 중괄호와 세미콜론을 사용하지
        않습니다 .scss 확장자는 기존 css와 별반 다르지
        않습니다
        -Sass 변수 및 믹스인은 다른 파일로 분리하여 작성한
        뒤 필요한 곳에서 쉽게 불러와 사용할 수 있습니다
        -sass-loader 설정을 커스터마이징하여 복잡한 디레턱리
        구조를 해결할 수 있습니다 이는 yarn eject 명령어를
        통해 사용합니다 
        -Sass의 장점 중 하나는 라이브러리를 쉽게 불러와서
        사용할 수 있다는 점입니다 ~문자를 사용하면
        node_modules에서 자동으로 경로를 찾아
        스타일을 불러옵니다 .scss파일을 불러오면 됩니다
    3.CSS Module
        -CSS Module은 CSS를 불러와서 사용할 떄 클래스
        이름을 [파일이름]_[클래스 이름]_[해시값] 형태로
        자동으로 만들어서 컴포넌트 스타일 클래스 이름이
        중첩되는 현상을 방지해 주는 기술입니다
        -.module.css 확장자로 파일을 저장하면 
        CSS Module이 적용됩니다
        -CSS Module을 사용하면 클래스 이름을 지을때
        그 고유성에 대해 고민하지 않아도 됩니다 해당 
        클래스는 우리가 방금 만든 스타일을 직접 불러온
        컴포넌트 내부에서만 작동하기 때문입니다
        -만약 특정 클래스가 웹 페이지에서 전역적으로
        사용되는 경우라면 :global을 앞에 입력합니다
        -CSS Module이 적용된 스타일 파일을 불러오면
        객체를 하나 전달받게 되는데 CSS Module에서 
        사용한 클래스 이름과 해당 이름을 고유화한 값이
        키-값 형태로 들어 있습니다
        -이 고유한 클래스 이름을 사용하려면 JSX 엘리먼트에
        className={객체.클래스이름} 형태로 전달합니다
        전역적으로 선언한 클래스의 경우 평상시와 같습니다
        -classnames라는 라이브러리로 CSS 클래스를 조건부로
        설정할 수 있습니다
        -Sass를 사용할 때도 파일 이름 뒤에 .module.scss
        확장자를 사용해주면 CSS Module로 사용할 수 있습니다
    
    4.styled-components
        -CSS-in-JS라고 부르는 자바스크립트 파일 안에 스타일을 
        선언하는 방식이 있습니다 CSS-in-JS 라이브러리 중에서
        개발자들이 가장 선호하는 style-components를 알아봅니다
        -자바스크립트 파일 하나에 스타일까지 작성할 수 있기에 .css
        or .scss 확장자를 가진 스타일 파일을 따로 만들지 않아도
        되는 큰 이점이 있습니다

        -Tagged 템플릿 리터럴:
        백턱을 사용하여 만든 문자열을 사용하는 리터럴을 Tagged 템플릿
        리터럴이라고 부릅니다
        일반 템플릿 리터럴과 다른 점은 템플릿 안에 자바스크립트 객체나
        함수를 전달할 때 온전히 추출할 수 있다는 것입니다

        -styled-components를 사용하여 스타일링된 엘리먼트를 만들
        때는 컴포넌트 파일의 상단에서 styled를 불러오고, 
        styled.태그명을 사용하여 구현합니다
            
