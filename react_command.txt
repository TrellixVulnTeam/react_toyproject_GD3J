yarn create react-app <project-name> :
    리액트 프로젝트 생성

Reactjs code Snippet:
    rsc : 함수형 컴포넌트 생성
    rcc : 클래스형 컴포넌트 생성

JSX 문법 :
    1.감싸인 요소
        -컴포넌트에 여러 요소가 있다면, 부모 요소 하나로 감싸야한다.
        이 떄 <div>와 <Fragment>, <> (Fragment의 다른 형태)를 쓸 수 있다.

    2.자바스크립트 표현
        -자바스크립트 표현을 쓰고 싶다면 JSX내부에서 코드를 {}로 감싸면 된다.
        -ES6의 const와 let
            const는 변경이 불가능한 상수
            let은 동적인 값을 담을 수 있는 변수
            var는 scope(해당 값을 사용할 수 있는 코드 영역)가 함수 단위
            let과 const는 scope가 블록 단위

    3.if문 대신 조건부 연산자 (삼항연산자)
        -jsx에서는 if문 사용 불가
        -{} 안에 조건부 연산자를 사용
        -&&를 이용한 조건부 연산이 가능한 이유는 리액트는 false와 null를 렌더링할 때
        아무것도 나타나지 않음

    note:
        jsx는 괄호로 감싸는 것이 필수사항이 아님 감싸도 되고 안 감싸도 된다

    4.undefined를 렌더링하지 않기
        -리액트 컴포넌트에서는 undefined만 반환하여 렌더링하는 상황을 만들면 안된다
        -어떤 값이 undefined일 수도 있다면 or 연산자를 사용한다
        -jsx내부에서 undefined를 렌더링하는 것은 괜찮다
    
    5.인라인 스타일링
        - 스타일 이름 중에 -가 포함되어있다면 (background-color) -> backgroundColor
        로 카멜표기법을 이용해 바꾸어 준다.
        -style 객체를 미리 선언하고 div의 style={스타일 객체}를 넣어주는 방법과
        바로 객체로 넣어주는 방법이 있다
    
    6.class대신 className
        -html에서 css클래스를 사용할 때는 <div class="name"></div>와 같이 
        사용했다면, jsx에서는 class가 아닌 className을 써줘야 한다.
    
    7.꼭 닫아야 하는 태그
        -html에서는 태그를 닫지 않아도 오류를 출력하지 않고 자동으로 처리해주지만,
        리액트에서는 태그를 꼭 닫아줘야 한다.

    8.주석
        -JSX는 javascript와 달리 주석을 작성할 때는 {/*...*/}와 같은 형식으로 작성
        합니다. 시작태그를 여러 줄로 작성하게 되면 //으로 작성할 수도 있습니다.

ES6 문법:
    1.화살표 함수
        -이 문법은 주로 함수를 파라미터로 전달할 때 유용합니다.
        -이 문법은 기존 function을 대체 불가능합니다. 서로 가르키고 있는 this값이
        다르기 때문입니다.
        - () => { 함수 내 선언문; } 형식으로 사용하며 {}를 열어주지 않을시 연산값을
        그대로 반환합니다.
        - 함수형 컴포넌트를 사용할 때는 function과 화살표을 쓰는 것에 큰 차이가 없습니다
    
    2.비구조화 할당 문법
        -객체에서 값을 추출하는 문법을 비구조화 할당이라고 부릅니다.
        -const {name, children} = props 이런 식으로 할당할 수 있습니다.
        -함수의 파라미터에서도 사용 가능합니다.
        -배열은 const [one, two] = array 이런 식으로 사용합니다


컴포넌트 :
    1.선언
        -컴포넌트를 선언하는 방식은 두 가지로 하나는 함수형 컴포넌트, 또 다른 하나는 
        클래스형 컴포넌트입니다.
        -둘의 차이는 클래스형 컴포넌트의 경우 state 기능과 라이프사이클 기능을 사용할 수
        있다는 것과 임의 메서드를 정의할 수 있다는 것입니다.
        -클래스형 컴포넌트는 render함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할
        JSX를 반환해야 합니다.
        -함수형 컴포넌트의 장점은 선언하기 편하고, 메모리 자원도 덜 사용합니다.
        -함수형 컴포넌트는 Hooks를 사용해 클래스형과 비슷하게 사용 가능합니다.
    
    2.모듈 내보내기 및 불러오기
        -export는 다른 파일에서 이 파일을 임포트할 때 줄 클래스를 선언합니다.
        -import는 다른 파일에서 파일을 불러올 때 쓸 클래스를 선언합니다.
    
    3.props
        -props는 properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는
        요소입니다.
        -props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정할 수 있습니다
        -props 기본값 설정은 defaultProps로 합니다
        -부모 컴포넌트의 태그 사이의 내용은 children으로 들어갑니다
    
    4.propTypes를 통한 검증
        -propTypes를 통해 prop의 타입을 강제하거나 필수 prop을 정할 수 있습니다.
        -isRequired를 통해 필수 prop을 설정합니다
        -PropTypes 종류:
            array, arrayOf(다른 PropType) : 특정 PropType으로 이루어진 배열,
            bool, func, number, object, string, symbol, node,
            instanceOf(클래스), oneOf([]): 배열 요소 중 값 하나,
            oneOfType([]): 주어진 배열 안의 종류 중 하나, any
    
    5.클래스형 컴포넌트에서 props 사용
        -클래스형 컴포넌트에서는 render 함수에서 this.props를 조회하면 됩니다.
        -defaultProps와 propTypes를 클래스 내부에서 저장하는 방법도 있습니다
        -defaultProps와 propTypes는 다른 개발자들과 협업할 때, 컴포넌트에 어떤 
        prop이 필요한지 쉽게 알려줍니다.

    6.state
        -두 가지 종류의 state가 있습니다. 하나는 클래스형 컴포넌트가 가지고 있는
        state이고, 다른 하나는 함수형 컴포넌트에서 useState()라는 함수를 통해 사용하는
        state입니다.
        -클래스형 컴포넌트의 state:
            *컴포넌트의 생성자 메소드를 작성하고 반드시 super(props)를 호출해주세요
            *컴포넌트의 state는 객체 형식이어야 합니다
            *render 함수에서 현재 state를 조회할 때는 this.state를 조회하면 됩니다
            *생성자 메소드 없이 state = {값}으로 초기값을 지정할 수 있습니다
        -this.setState()로 state를 바꿀 수 있습니다 이 때 인자로 객체와 함수를 줄
        수 있습니다 함수를 줄 때는 (prevState, props)를 줄 수 있습니다 prevState는
        기존 상태이고 props는 현재 지니고 있는 props를 가르킵니다
        -this.setState가 끝난 후 특정 작업 실행하려면 두번째 인자로 특정 작업을 실행하는
        콜백함수를 등록합니다
        -useState 함수의 인자에는 상태의 초기값을 넣어줍니다. 값의 형태는 자유입니다.
        함수를 호출하면 배열이 반환되는데, 첫번째 원소는 현재 상태이고, 두 번째 원소는
        상태를 바꾸어주는 함수입니다. 이 함수를 setter라고 부릅니다. 원소를 받을 때
        비구조화 할당을 쓸 수 있습니다.
        -useState는 한 컴포넌트에서 여러번 사용해도 상관없습니다.
        -state를 사용할 때 주의 사항:
            state 값을 바꿔야 할 때는 setState 혹은 useState를 통해 전달받은
            세터 함수를 사용해야 합니다
            배열이나 객체를 업데이트 해야할 때는 사본을 만들고 그 사본의 상태를
            세터함수를 통해 업데이트합니다
        -앞으로 새로운 컴포넌트를 만들 때는 useState를 사용할 것을 권장합니다
        코드가 간결해지고 개발 팀에서 Hooks를 사용하는 것이 주가 될 것이라고 발표했기
        때문입니다

이벤트 핸들링:
    1.이벤트를 사용할 때 주의사항
        -이벤트 이름은 카멜 표기법으로 작성합니다
        -이벤트에 실행할 자바스크립트를 전달하는 것이 아니라, 함수 형태의 값을 전달합니다
        -DOM 요소에만 이벤트를 설정할 수 있습니다 컴포넌트에 자체적으로 이벤트를 설정할 수
        는 없습니다 하지만 전달받은 props를 컴포넌트 내부의 DOM 이벤트로 설정할 수는 있죠
    2.임의 메서드 만들기
        -임의 메소드가 이벤트로 등록되어도 this를 컴포넌트 자신으로 제대로 가르키기 위해서
        는 메소드를 this와 바인딩하는 작업이 필요합니다 이를 위해 constructor 함수에서
        함수를 바인딩합니다
        -메소드 바인딩은 생성자 메소드에서 하는 것이 정석입니다만, 이 작업이 불편합니다
        이를 대체해 바벨의 transform-class-properties 문법을 사용하여 
        화살표 함수 형태로 메소드를 정의합니다
    3.input 여러개 다루기
        -input이 여러 개일 때는 메소드도 여러 개 만들어 작업할 수도 있지만, 더 쉽게
        처리하는 방법이 있습니다 event 객체를 활용하는 것 입니다
        -e.target.name은 input의 name을 가르킵니다
        -객체 안에 key를 [ ]로 감싸면 그 안에 넣은 레퍼런스가 가르키는 실제 값이
        key 값으로 사용됩니다
    4.함수형 컴포넌트
        -useState를 통해 클래스형과 똑같이 다룰 수 있습니다

ref:
    1.ref란?
        -ref는 리액트 프로젝트 내부에서 DOM에 이름을 다는 방법입니다 DOM의 id와 비슷합니다
        -id를 사용할 수도 있습니다만, 권장하지는 않습니다 같은 컴포넌트를 여러번 사용하다보면
        id가 유일해지지 않기 때문입니다 ref는 전역적으로 작동하지 않기 때문에 이런 문제가
        생기지 않습니다
    2.어떤 상황에서 ref를 사용하는가
        -DOM을 꼭 직접적으로 건드려야 할 때 사용합니다
        -DOM을 꼭 사용해야 하는 상황
            특정 input에 포커스 주기
            스크롤 박스 조작하기
            Canvas 요소에 그림 그리기 등
    3.ref 사용
        -콜백 함수를 통한 ref 설정: ref를 달고자 하는 요소에 ref라는 콜백 함수를 
        props로 전달해 줍니다 그리고 함수 내부에서 파라미터로 받은 ref를 컴포넌트의
        멤버 변수로 설정해 줍니다
        -createRef를 통한 ref 설정: 리액트에 내장되어 있는 createRef라는 함수를
        사용합니다 설정한 뒤 나중에 ref를 설정해 준 DOM에 접근하려면 this.input.
        current를 조회합니다
    4.컴포넌트에 ref 달기
        -이 방법은 주로 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 씁니다
        컴포넌트에 ref를 다는 방법은 DOM에 ref를 다는 방법과 같습니다
        -사용법 <MyComponent ref={(ref)=>{this.myComponent = ref}}/>
        -이렇게 하면 MyComponent 내부의 메소드 및 멤버 변수에도 접근 가능합니다
    5.ref를 사용할 때 주의할 점
        -서로 다른 컴포넌트끼리 데이터를 교류할 때 ref를 사용하지 않습니다
        사용할 수는 있지만, 유지보수 문제 때문에 사용하지 않습니다

컴포넌트 반복:
    